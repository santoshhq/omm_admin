import 'package:flutter/material.dart';

/// Simple user model to collect registration data across steps.
class MemberRegistrationModel {
  // MongoDB document ID
  String? id;

  // Step 1
  ImageProvider? profileImage;
  String? firstName;
  String? lastName;
  String? mobile;
  String? email;

  // Step 2
  String? floor; // I, II, III, IV, V
  String? flatNo;
  String? paymentStatus; // Booked, Available, Pending
  String? parkingArea; // P1 or P2
  String? parkingSlot; // P1-1, P2-4, etc.

  // Step 3
  String? govtIdType; // AadharCard etc.
  ImageProvider? govtIdImage;

  // Step 4 - credentials
  String? userId; // autogenerated
  String? password;

  MemberRegistrationModel();

  /// Helper to get a light color based on floor
  /// Helper to get a light color based on floor
  Color get floorColor {
    switch (floor) {
      case 'I':
        return Colors.red.shade50;
      case 'II':
        return Colors.green.shade50;
      case 'III':
        return Colors.blue.shade50;
      case 'IV':
        return Colors.orange.shade50;
      case 'V':
        return Colors.purple.shade50;
      case 'VI':
        return Colors.teal.shade50;
      default:
        return Colors.grey.shade100; // fallback
    }
  }

  /// Helper to get the primary color based on floor
  MaterialColor get floorPrimaryColor {
    switch (floor) {
      case 'I':
        return Colors.red;
      case 'II':
        return Colors.green;
      case 'III':
        return Colors.blue;
      case 'IV':
        return Colors.orange;
      case 'V':
        return Colors.purple;
      case 'VI':
        return Colors.teal;
      default:
        return Colors.grey; // fallback
    }
  }

  /// Helper to get light background color (same as floorColor)
  Color get floorLightColor {
    return floorColor; // Uses the existing light colors
  }

  /// Helper to get medium shade color for UI elements
  Color get floorMediumColor {
    switch (floor) {
      case 'I':
        return Colors.red.shade100;
      case 'II':
        return Colors.green.shade100;
      case 'III':
        return Colors.blue.shade100;
      case 'IV':
        return Colors.orange.shade100;
      case 'V':
        return Colors.purple.shade100;
      case 'VI':
        return Colors.teal.shade100;
      default:
        return Colors.grey.shade200; // fallback
    }
  }

  /// Helper to get darker shade color for text/icons
  Color get floorDarkColor {
    switch (floor) {
      case 'I':
        return Colors.red.shade700;
      case 'II':
        return Colors.green.shade700;
      case 'III':
        return Colors.blue.shade700;
      case 'IV':
        return Colors.orange.shade700;
      case 'V':
        return Colors.purple.shade700;
      case 'VI':
        return Colors.teal.shade700;
      default:
        return Colors.grey.shade700; // fallback
    }
  }

  /// Helper to check if email is valid for password reset
  bool get hasValidRecoveryEmail {
    return email != null &&
        email!.isNotEmpty &&
        RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(email!);
  }

  /// Helper to get recovery email status text
  String get recoveryEmailStatus {
    if (email == null || email!.isEmpty) {
      return 'No recovery email provided';
    } else if (!hasValidRecoveryEmail) {
      return 'Invalid email format';
    } else {
      return 'Recovery email available';
    }
  }

  /// Convert model to backend API format for admin member creation
  Map<String, dynamic> toBackendJson(String adminId) {
    return {
      'adminId': adminId,
      'userId': userId,
      'password': password,
      'profileImage': profileImage?.toString(),
      'firstName': firstName,
      'lastName': lastName,
      'mobile': mobile,
      'email': email,
      'floor': floor,
      'flatNo': flatNo,
      'paymentStatus': paymentStatus ?? 'Available',
      'parkingArea': parkingArea,
      'parkingSlot': parkingSlot,
      'govtIdType': govtIdType,
      'govtIdImage': govtIdImage?.toString(),
    };
  }

  /// Create model from backend response
  static MemberRegistrationModel fromBackendJson(Map<String, dynamic> json) {
    final model = MemberRegistrationModel();
    model.firstName = json['firstName'];
    model.lastName = json['lastName'];
    model.mobile = json['mobile'];
    model.email = json['email'];
    model.floor = json['floor'];
    model.flatNo = json['flatNo'];
    model.paymentStatus = json['paymentStatus'];
    model.parkingArea = json['parkingArea'];
    model.parkingSlot = json['parkingSlot'];
    model.govtIdType = json['govtIdType'];
    model.userId = json['userId'];
    // Note: password is not returned from backend for security
    return model;
  }
}

class ParkingService {
  static final Set<String> _reservedSlots = {};

  static Future<Set<String>> getReservedSlots(String area) async {
    await Future.delayed(const Duration(milliseconds: 200));
    return _reservedSlots
        .where((s) => s.startsWith(area.toLowerCase()))
        .toSet();
  }

  static Future<bool> reserveSlot(String slot) async {
    await Future.delayed(const Duration(milliseconds: 200));
    if (_reservedSlots.contains(slot)) return false;
    _reservedSlots.add(slot);
    return true;
  }

  static void clearForTesting() => _reservedSlots.clear();
}
